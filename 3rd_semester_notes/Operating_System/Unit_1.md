### Operating System (OS) - Introduction

An **Operating System (OS)** is system software that manages hardware and software resources in a computer system and provides services to programs. It acts as an intermediary between users and the hardware. Without an OS, the hardware is difficult to use and manage. Some major roles of an OS are:
- Managing hardware resources like CPU, memory, and I/O devices.
- Providing a user interface.
- Managing files and directories.
- Facilitating the execution of programs.

---

### Simple Batch Systems

In **Simple Batch Systems**, users submit their jobs to the computer, and the OS batches the jobs together to process them sequentially. There's no user interaction once a job starts. The OS keeps the CPU busy by reducing idle time between tasks.
- **Advantage:** Increased CPU utilization.
- **Disadvantage:** Lack of interactivity with users.


![Batch Operating System Diagram](https://files.prepinsta.com/2023/06/Batch-Operating-System.webp)

---

### Multi-programmed Batch Systems

**Multi-programming** allows the OS to load several programs in memory and execute them concurrently. When one job is waiting for I/O, the CPU can switch to another job, ensuring better utilization of the system.
- **Advantage:** Improved CPU utilization compared to single batch systems.
- **Disadvantage:** Requires more sophisticated memory and process management.


![Multi-programmed Batch Systems](https://cdn1.byjus.com/wp-content/uploads/2022/08/word-image-4.png)

---

### Time-Sharing Systems

**Time-sharing systems** are an extension of multi-programming where the CPU executes multiple jobs by rapidly switching between them, giving the illusion that the system is dedicated to each user. Each job is allocated a time slice.
- **Advantage:** Interactive system where multiple users can work simultaneously.
- **Disadvantage:** Requires efficient scheduling and resource management.


![Time-Sharing System](https://cdn1.byjus.com/wp-content/uploads/2022/08/word-image-13.png)
---

### Personal-Computer Systems

**Personal-Computer (PC) Systems** are designed for individual users. They have less sophisticated operating systems compared to large systems but provide sufficient services for personal use.
- Example: Windows, macOS, Linux distributions.

---

### Parallel Systems

**Parallel systems** have multiple processors working together to perform tasks. These processors can either share memory or have separate memory, and work on different parts of a problem simultaneously.
- **Advantage:** Increased processing power and speed.
- **Disadvantage:** Complexity in managing synchronization and memory access.


***Click here to watch the video -->***
[Parallel vs Distributed Operating System](https://youtu.be/pPFBgN2XSTY?si=RrbzKP7bQ0PVYQ-r)
---

### Distributed Systems

**Distributed systems** consist of multiple computers working together, appearing to users as a single coherent system. Resources are shared, and communication is required between machines.

 Each machine has a piece of the distributed OS installed to allow them to communicate. Because they must deal with a variety of networking protocols, distributed Operating Systems are far more sophisticated, massive, and complex than network Operating Systems.

- **Advantage:** Scalability and fault tolerance.
- **Disadvantage:** Complexity in communication and synchronization.


![Distributed System](https://cdn1.byjus.com/wp-content/uploads/2022/08/word-image-14.png)
---

### Real-Time Systems

**Real-time systems** provide immediate processing and responses, ensuring tasks are completed within specific time constraints. Real-time systems are used in critical environments like embedded systems, medical devices, and aircraft.
- **Hard real-time:** Tasks must be completed within strict deadlines.
- **Soft real-time:** Some delays are acceptable.


---

## Memory Management

### Background

**Memory management** involves managing the computer's memory hierarchy (primary memory and secondary storage). The OS is responsible for allocating and deallocating memory to processes.

---

### Logical vs Physical Address Space

- **Logical Address:** Address generated by the CPU.
- **Physical Address:** Actual address in the memory unit.
The OS translates logical addresses to physical addresses using a **Memory Management Unit (MMU)**.

---

---
## 3. Memory Management Techniques

Several techniques are used by the OS to allocate and manage memory efficiently:

### a) Partitioning
- **Fixed Partitioning**: Memory is divided into fixed-size partitions. Each partition holds one process. However, this can lead to wasted space (**internal fragmentation**) if a process doesn't fully use its partition.
- **Dynamic Partitioning**: Memory is divided into partitions dynamically based on process needs. This helps reduce internal fragmentation but may lead to **external fragmentation**, where free memory is split into small, non-contiguous blocks.

### b) Paging
- **Paging** is a technique that divides memory into fixed-size blocks called pages. Physical memory (RAM) is divided into **page frames**, and the OS maps virtual memory addresses to physical memory using **page tables**.
  - Paging reduces external fragmentation.
  - It allows processes to use non-contiguous memory blocks, which simplifies memory allocation.

### c) Segmentation
- **Segmentation** divides memory into variable-sized segments based on logical divisions, such as code, data, and stack. Each segment has its own **base** and **limit address**. Unlike paging, which focuses on physical memory, segmentation deals with the logical view of memory. It allows more flexibility but may suffer from **external fragmentation**.

### d) Virtual Memory
- **Virtual memory** allows processes to run as if they have more RAM than is physically available. The OS uses paging or segmentation to map parts of processes into secondary storage (such as a hard drive) and loads them into RAM when needed. This provides several benefits:
  - Enables multitasking by giving each process its own virtual address space.
  - Facilitates **swapping**, where parts of memory can be temporarily moved to secondary storage when RAM is full.
  - Handles large applications that require more memory than available physical RAM.

---
### Swapping ---> [Click to watch Swapping Video](https://youtu.be/Kow9tovzVd4?si=-dMsJkFMR-ggGMH9&t=23)

**Swapping** is a memory management technique where processes are swapped between main memory and secondary storage to free up memory for active processes.

---

### Contiguous Allocation

In **Contiguous Allocation**, each process is assigned a single continuous block of memory. This approach is simple but can lead to fragmentation issues.

---

### Paging

**Paging** divides memory into fixed-sized blocks called **pages** and **frames**. The process's logical address space is divided into pages, and these are mapped to physical memory frames.
- **Advantage:** Avoids external fragmentation.

---

### Segmentation

**Segmentation** divides memory into variable-sized segments based on the program's logical divisions (e.g., code, data). Each segment is mapped to memory.



---
---

### 1. **Contiguous Memory Allocation**

In **contiguous memory allocation**, each process is assigned a single, continuous block of memory. The entire memory space for a process is stored in one sequential section of RAM.

#### Advantages of Contiguous Memory Allocation:
- **Simple to implement**: Easier to manage since each process gets a single block of memory.
- **Faster access**: Because memory is allocated in one continuous block, it allows for faster access to process data.
- **Direct address translation**: The address of memory for a process is simple to calculate because it is contiguous.

#### Disadvantages of Contiguous Memory Allocation:
- **External Fragmentation**: Over time, free memory can become fragmented into small, non-contiguous chunks, which can prevent large processes from getting sufficient memory.
- **Inefficient use of memory**: Fixed partitioning can cause underutilization of memory when a process is smaller than its partition, leading to internal fragmentation.
- **Limited process size**: The size of a process is limited to the size of the largest available contiguous block of memory.

#### Example:
If the OS has a block of 100 MB available in RAM, a process requesting 90 MB will be allocated the entire block contiguously. However, if the process is only 50 MB in size, 40 MB will go to waste (internal fragmentation in fixed partitioning).

---

### 2. **Non-Contiguous Memory Allocation**

In **non-contiguous memory allocation**, a processâ€™s memory is divided into several blocks, and these blocks can be scattered throughout physical memory. The OS uses techniques like **paging** or **segmentation** to manage these blocks.

#### Characteristics:
- **Scattered allocation**: The process can occupy multiple blocks of memory located at different places in RAM.
- **Address translation**: Non-contiguous allocation requires additional mechanisms to translate logical addresses to physical addresses.

#### Types of Non-Contiguous Allocation:
- **Paging**: Memory is divided into fixed-size blocks called **pages** (for processes) and **frames** (for physical memory). Pages can be placed in any available frame in memory.
  - **Advantages**: No external fragmentation; efficient memory use.
  - **Disadvantages**: Can have **page table overhead**, which maps pages to frames, and slower access times due to scattered memory blocks.

- **Segmentation**: Memory is divided into segments based on logical divisions (such as code, data, and stack). Each segment can be placed in different areas of physical memory.
  - **Advantages**: Provides a logical view of memory; segments can grow independently.
  - **Disadvantages**: Can lead to **external fragmentation** and more complex address translation.

#### Advantages of Non-Contiguous Memory Allocation:
- **Efficient memory use**: Non-contiguous allocation allows memory to be used more efficiently since processes can use fragmented free memory blocks.
- **No external fragmentation**: Especially in paging, there is no external fragmentation since the fixed-size pages can fit into any available frame.
- **Larger process size support**: A process can occupy as much memory as is available, even if the free memory blocks are scattered throughout RAM.
- **Easy swapping**: Non-contiguous memory allocation makes it easier to swap portions of memory to disk (in virtual memory).

#### Disadvantages of Non-Contiguous Memory Allocation:
- **Complex address translation**: Logical addresses need to be translated into physical addresses using **page tables** (in paging) or **segment tables** (in segmentation), which adds overhead.
- **Performance overhead**: Accessing non-contiguous blocks may involve more memory lookups, leading to slower memory access compared to contiguous allocation.
- **More complicated management**: The OS needs to maintain tables (e.g., page tables, segment tables) to map virtual memory to physical memory, increasing complexity.

#### Example:
In **paging**, if a process needs 16 KB of memory and each page is 4 KB, the OS divides the process into 4 pages. These 4 pages can be placed in any available frames in RAM, even if they are scattered across different memory locations.

---

---


## Virtual Memory

### Demand Paging

In **Demand Paging**, pages are loaded into memory only when they are required. This reduces memory load but requires a mechanism to handle page faults (when a page is not in memory).

---

### Page Replacement Algorithms

When memory is full, **Page Replacement Algorithms** decide which page to replace. Some common algorithms are:
- **FIFO (First In, First Out)**
- **LRU (Least Recently Used)**
- **Optimal Page Replacement**

---

### Thrashing

**Thrashing** occurs when a system spends more time swapping pages in and out of memory than executing processes. It results in significant performance degradation.

---

### Important Questions for Exam:

1. What are the main functions of an operating system?
2. Compare simple batch systems with multi-programmed batch systems.
3. Explain time-sharing systems and how they differ from batch systems.
4. Describe parallel and distributed systems. What are the key differences?
5. Explain the concept of logical and physical addresses. How does the OS handle memory translation?
6. What is paging, and how does it help in memory management?
7. Compare contiguous allocation with segmentation and paging.
8. What is demand paging, and how does it differ from regular paging?
9. Explain different page replacement algorithms (FIFO, LRU, Optimal).
10. What is thrashing, and how can it be minimized?

### Summary for Exam:

1. Operating Systems - Types (Batch, Multi-programmed, Time-sharing, etc.)
2. Memory Management - Address Spaces, Paging, Segmentation
3. Virtual Memory - Page Replacement Algorithms, Thrashing
